/* eslint-disable no-await-in-loop */
import { assoc, fromPairs, head, isEmpty, last, map, mapObjIndexed, pipe, values } from 'ramda';
import moment from 'moment';
import pubsub from '../config/bus';
import instance from '../database/grakn';
import driver from '../database/neo4j';
import { FunctionalError } from '../config/errors';
import { MALWARE_ADDED_TOPIC } from '../config/conf';
import { decrypt, encrypt } from '../config/crypto';

const pageInfo = (
  startCursor = '',
  endCursor = '',
  hasNextPage = false,
  hasPreviousPage = false
) => ({
  startCursor,
  endCursor,
  hasNextPage,
  hasPreviousPage
});

export const findAll = async (first = 25, after = undefined) => {
  const skip = after ? parseInt(decrypt(after), 10) : 0;
  const pCountInstances = instance({
    method: 'post',
    url: '/kb/grakn/graql',
    data: `match $count isa Malware; aggregate count;`
  }).then(result => head(result.data));
  const pResultInstances = instance({
    method: 'post',
    url: '/kb/grakn/graql',
    data: `match $x isa Malware; offset ${skip}; limit ${first}; get;`
  }).then(result =>
    Promise.all(
      map(line =>
        instance({
          method: 'get',
          url: `${line.x['@id']}/attributes`
        }).then(res =>
          Promise.resolve(
            fromPairs(
              map(attr => {
                const label =
                  attr.type.label === 'stix_id' ? 'id' : attr.type.label;
                return [label, attr.value];
              })(res.data.attributes)
            )
          )
        )
      )(result.data)
    )
  );
  return Promise.all([pCountInstances, pResultInstances]).then(mergedData => {
    const globalCount = head(mergedData);
    const malwares = last(mergedData);
    const edges = pipe(
      mapObjIndexed((record, key) => {
        const node = record;
        const cursor = encrypt(skip + parseInt(key, 10) + 1);
        return { node, cursor };
      }),
      values
    )(malwares);
    const hasNextPage = first + skip < globalCount;
    const hasPreviousPage = skip > 0;
    const startCursor = head(edges).cursor;
    const endCursor = last(edges).cursor;
    const page = pageInfo(startCursor, endCursor, hasNextPage, hasPreviousPage);
    return { edges, pageInfo: page };
  });
};

export const findById = malwareId => {
  const session = driver.session();
  const promise = session.run(
    'MATCH (malware:Malware {id: {malwareId}}) RETURN malware',
    { malwareId }
  );
  return promise.then(data => {
    session.close();
    if (isEmpty(data.records))
      throw new FunctionalError({ message: 'Cant find this malware' });
    return head(data.records).get('malware').properties;
  });
};

export const addMalware = async malware => {
  const completeMalware = pipe(
    assoc('type', 'malware'),
    assoc('created_at', moment().toISOString()),
    assoc('revoked', false)
  )(malware);
  const session = driver.session();
  const promise = session.run(
    'CREATE (malware:Malware {malware}) RETURN malware',
    { malware: completeMalware }
  );
  return promise.then(data => {
    session.close();
    const malwareAdded = head(data.records).get('malware').properties;
    pubsub.publish(MALWARE_ADDED_TOPIC, { malwareAdded });
    return malwareAdded;
  });
};

export const deleteMalware = malwareId => {
  const session = driver.session();
  const promise = session.run(
    'MATCH (malware:Malware {id: {malwareId}}) DELETE malware RETURN malware',
    { malwareId }
  );

  return promise.then(data => {
    session.close();
    if (isEmpty(data.records)) {
      throw new FunctionalError({ message: "Malware doesn't exist" });
    } else {
      return malwareId;
    }
  });
};
