import { assoc, head, isEmpty, mapObjIndexed, values, pipe, last } from 'ramda';
import moment from 'moment';
import pubsub from '../config/bus';
import driver from '../database/neo4j';
import { FunctionalError } from '../config/errors';
import { MALWARE_ADDED_TOPIC } from '../config/conf';
import { decrypt, encrypt } from '../config/crypto';

const pageInfo = (
  startCursor = '',
  endCursor = '',
  hasNextPage = false,
  hasPreviousPage = false
) => ({
  startCursor,
  endCursor,
  hasNextPage,
  hasPreviousPage
});

export const findAll = (first = 25, after = undefined, orderBy = 'id') => {
  const skip = after ? parseInt(decrypt(after), 10) : 0;
  const session = driver.session();
  const query = `MATCH (g:Malware) WITH count(g) as global MATCH (malware:Malware) RETURN malware, global ORDER BY malware.${orderBy.toLowerCase()} SKIP {skip} LIMIT {limit}`;
  const promise = session.run(query, {
    skip: skip + 1,
    limit: first
  });
  console.log('first:', first);
  console.log('skip:', skip);
  return promise.then(data => {
    session.close();
    if (isEmpty(data.records)) {
      return { edges: [], pageInfo: pageInfo() };
    }
    // Transform the result to be relay compliant.
    const globalCount = head(data.records).get('global');
    console.log('globalCount:', globalCount);
    const edges = pipe(
      mapObjIndexed((record, key) => {
        const node = record.get('malware').properties;
        const cursor = encrypt(skip + parseInt(key, 10) + 1);
        return { node, cursor };
      }),
      values
    )(data.records);
    const hasNextPage = first + skip < globalCount;
    const hasPreviousPage = skip > 0;
    const startCursor = head(edges).cursor;
    const endCursor = last(edges).cursor;
    const page = pageInfo(startCursor, endCursor, hasNextPage, hasPreviousPage);
    return { edges, pageInfo: page };
  });
};

export const findById = malwareId => {
  const session = driver.session();
  const promise = session.run(
    'MATCH (malware:Malware {id: {malwareId}}) RETURN malware',
    { malwareId }
  );
  return promise.then(data => {
    session.close();
    if (isEmpty(data.records))
      throw new FunctionalError({ message: 'Cant find this malware' });
    return head(data.records).get('malware').properties;
  });
};

export const addMalware = async malware => {
  const completeMalware = pipe(
    assoc('type', 'malware'),
    assoc('created_at', moment().toISOString()),
    assoc('revoked', false)
  )(malware);
  const session = driver.session();
  const promise = session.run(
    'CREATE (malware:Malware {malware}) RETURN malware',
    { malware: completeMalware }
  );
  return promise.then(data => {
    session.close();
    const malwareAdded = head(data.records).get('malware').properties;
    pubsub.publish(MALWARE_ADDED_TOPIC, { malwareAdded });
    return malwareAdded;
  });
};

export const deleteMalware = malwareId => {
  const session = driver.session();
  const promise = session.run(
    'MATCH (malware:Malware {id: {malwareId}}) DELETE malware RETURN malware',
    { malwareId }
  );

  return promise.then(data => {
    session.close();
    if (isEmpty(data.records)) {
      throw new FunctionalError({ message: "Malware doesn't exist" });
    } else {
      return malwareId;
    }
  });
};
