import { withFilter } from 'graphql-subscriptions';
import { assoc } from 'ramda';
import { logger, BUS_TOPICS } from '../config/conf';
import {
  addMalware,
  deleteMalware,
  findAll,
  findById,
  findMarkingDef,
  killChainPhases,
  malwareEditContext,
  malwareEditField
} from '../domain/malware';
import { pubsub } from '../database/redis';
import { admin, auth } from './wrapper';

const malwareResolvers = {
  Query: {
    malware: auth((_, { id }) => findById(id)),
    malwares: auth((_, args) => findAll(args))
  },
  Malware: {
    markingDefinitions: (malware, args) => findMarkingDef(malware.id, args),
    killChainPhases: (malware, args) => killChainPhases(malware.id, args)
  },
  Mutation: {
    malwareEdit: admin((_, { id }, { user }) => ({
      delete: () => deleteMalware(id),
      patch: ({ input }) => malwareEditField(user, assoc('id', id, input)),
      notify: ({ input }) => malwareEditContext(user, input)
    })),
    malwareAdd: admin((_, { input }, { user }) => addMalware(user, input))
  },
  Subscription: {
    malwareEdit: {
      resolve: payload => ({ malware: payload.data, context: [] }),
      subscribe: admin((_, args, { user }) =>
        withFilter(
          () => pubsub.asyncIterator(BUS_TOPICS.Malware.EDIT_TOPIC),
          payload => {
            if (!payload) return false; // When disconnect, an empty payload is dispatched.
            logger.debug(`${BUS_TOPICS.Malware.EDIT_TOPIC}-user`, user);
            logger.debug(`${BUS_TOPICS.Malware.EDIT_TOPIC}-payload`, payload);
            return true;
          }
        )(_, args, { user })
      )
    }
  }
};

export default malwareResolvers;
